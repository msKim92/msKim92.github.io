[ { "title": "행위패턴 - 전략패턴과 상태 패턴", "url": "/posts/strategy/", "categories": "CS, Design Pattern", "tags": "cs, design pattern", "date": "2023-01-07 10:11:07 +0900", "snippet": "Strategy Pattern &amp; State Pattern 🧙‍♂️ 디자인 패턴이란? 디자인 패턴이란? 디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제를 자주 쓰이는 설계 방법을 정리한 패턴이다. 디자인 패턴을 참고하여 개발하면 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화가 된다고 한다.　 디자인 패턴을 목적과 범위로 나눌수 있다 구분 유형 설명   생성 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행 목적 구조 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴   행위 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 범위 클래스 클래스간 관련성(상속), 컴파일 시 정적으로 결정   객체 객체 간 관련성을 다루는 패턴, 런타임 시 동적으로 결정 　　 전략 패턴은 인스턴스를 생성하고 난 후, 상태가 거의 바뀌지 않는 경우에 사용 상태 패턴은 인스턴스를 생성하고 난 후, 상태가 빈번하게 바뀌는 경우에 사용 전략 패턴이란? strategy pattern 정책패턴이라고 하며, 객체의 행위를 바꾸고 싶을떄 직접 수정하지 않고 ‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주면서 상호간의 교체가 가능하도록 만드는 패턴이다.결제시스템에서 카카오페이든 네이버페이든 전략만 바꿔서 결제를 진행하도록 해주는 것이 전략 패턴이다.인스턴스 오리가 태어날떄 꼭 한가지는 가지고 태어난다고 가정해보자. 날 수있는 오리 날 수없는 오리한번 인스턴스가 생성(태어나면) 살아가는 동안 날지 못하는 오리가 갑자기 날 수는 없는 것이다.즉, 상태가 바뀌지 않는다.interface Fly{ public void fly();}class canfly implements Duck{ @Override public void fly(){ System.out.print(\"날수 있다.\"); } }class cannotfly implements Duck{ @Override public void fly(){ System.out.print(\"날수 없다.\"); } }이런식으로 코드를 짜면 수정이나 기능을 추가시에 메서드의 중복문제가 발생과 OCP를 위반하게 된다.abstract class Duck{ private String name; private FlyingStrategy flyingStrategy; public Duck(String name) { this.name = name; } public void fly() { System.out.printf(name +\"는 \"); flyingStrategy.fly(); } public void setFlyingStrategy(FlyingStrategy flyingStrategy) { this.flyingStrategy = flyingStrategy; }}class blackDuck extends Duck{ public blackDuck(String name){ super(name); }}class whiteDuck extends Duck{ public whiteDuck(String name){ super(name); }}//fly 인터페이스interface FlyingStrategy{ public void fly();}//fly 구현체class canFly implements FlyingStrategy { @Override public void fly() { System.out.println(\"can fly\"); }}//fly 구현체class cannotFly implements FlyingStrategy { @Override public void fly() { System.out.println(\"cannot fly\"); }}public class Client { public static void main(String[] args) { blackDuck blackDuck = new blackDuck(\"검정오리\"); whiteDuck whiteDuck = new whiteDuck(\"흰오리\"); blackDuck.setFlyingStrategy(new canFly()); whiteDuck.setFlyingStrategy(new cannotFly()); blackDuck.fly(); whiteDuck.fly(); }}//검정오리는 can fly//흰오리는 cannot fly 상태 패턴이란? state pattern상태 객체에 일련의 행동이 캡슐화가 된다. 즉, 실행중인 객체가 여러 상태 객체중 하나인 객체에게 모든 행동을 맞기게 된다.아래와 같이 자판기기계가 있다고 가정해보자..1. 이 경우에는 기계가 HasMoney() 상태 있을때 insert_money()가 호출되면서 Sold() 상태로 전환된다. ==&gt; 돈이 부족할때 NoMoney(); ==&gt; 돈이 있을때 HasMoney();-insert_money()-&gt; Vending Machine =[현재 상태]=&gt; 거스름돈이 없을떄 NoChange(); ==&gt; 다 팔렸을때 SoldOut(); ==&gt; 팔릴떄 Sold();2. 현재 상태가 Sold 메서드로 전환되면서 음료를 반출한다. ==&gt; 돈이 부족할때 NoMoney(); ==&gt; 돈이 있을때 HasMoney(); ==&gt; 거스름돈이 없을떄 NoChange(); ==&gt; 다 팔렸을때 SoldOut();Vending Machine=[현재 상태]+ dispense()=&gt; 팔릴떄 Sold();3. 그후 음료가 있으면 NoMoney(); , 거스름돈이없으면 NoChange(), 매진 시 SoldOut()으로 이동한다.이처럼 상태를 빈번히 바뀌는 경우 상태패턴을 사용한다. 코드를 간단하게 짜보겠다.변경전 로직public class VendingMachine { public static enum State {NoMoney, HasMoney, ...} private State state = State.NoMoney; public void changeState(State state){ this.state=state; } public void insert_money(int money) { switch (state) { case NoMoney: case HasMoney: case Nochange: case SoldOut: case Sold: } }}벌써부터 case 문을 보면 속이 답답하다..변경후 로직… 우선 인터페이스를 만들자.interface State{ public void money(int money, VendingMachine machine);}class NoMoney implements State{ @Override public void money(int money, VendingMachine machine) { ... }}class HasMoney implements State{ @Override public void money(int money, VendingMachine machine){ machine.changeState(new Sold()); }}class Sold implements State{ @Override public void money(int money, VendingMachine machine){ machine.changeState(new NoMoney()); }}public class VendingMachine { private State state; public VendingMachine() { state = new NoMoney(); } public void insert_money(int money) { state.money(money, this); // 핵심포인트: 구현위임 } public void changeState(State state){ this.state = state; }} 공통점차이점은 위에 말한것처럼 state는 능동적으로 변하고 strategy는 수동적으로 변하는 성질이 있다.공통점은 실행중인 클래스의 영향을 받지않고 유연한 변환이 가능한 점이다. 결론전략 패턴: 생성 시, 비슷하면서 조금씩 다른 행동을 묶고 싶을때 사용한다.상태 패턴: if,else 조건문이 너무 많이 들어가 지저분해보일 때 사용한다. 출처 Head First 디자인패턴 면접을 위한 CS 전공지식노트" }, { "title": "생성 패턴 - 추상 팩토리 메서드 패턴", "url": "/posts/abstract/", "categories": "CS, Design Pattern", "tags": "cs, design pattern", "date": "2023-01-02 09:10:57 +0900", "snippet": "Abstract Factory Method Pattern 디자인 패턴이란? 디자인 패턴이란? 디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제를 자주 쓰이는 설계 방법을 정리한 패턴이다. 디자인 패턴을 참고하여 개발하면 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화가 된다고 한다.　 디자인 패턴을 목적과 범위로 나눌수 있다 구분 유형 설명   생성 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행 목적 구조 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴   행위 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 범위 클래스 클래스간 관련성(상속), 컴파일 시 정적으로 결정   객체 객체 간 관련성을 다루는 패턴, 런타임 시 동적으로 결정 　　 관련 객체들의 클래스들을 지정하지 않고 객체들의 모음을 생성하는 패턴편의점 삼각 김밥에 들어가는 재료들이 모두 다 한 공장에서 오진 않았다.재료마다 각기 다른 곳에서 와서 하나의 김밥이 되었다. 팩토리 패턴과의 차이: 팩토리 패턴은 한 종류의 객체를 생성하기 위해 사용되지만,추상 팩토리 패턴은 연관되거나 의존적인 객체로 이루어진 여러 종류의 객체를 생성하기 위해 사용된다. 추상 팩토리 메서드 패턴이란? 추상 팩토리 패턴은 상세화된 서브 클래스를 정의하지 않고, 서로 관련성이 있거나 독립적인 여러 객체를 생성하기 위한 인터페이스를 제공한다.최근 Spring Security에서 OAuth2를 쓰면서 각개의 소셜로그인에 계정에 맞는 user 정보를 api로 주게 되는데이러한 점이 추상 팩토리 메소드로 생각해 볼 수 있을꺼 같아 예제코드를 작성해보았다.팩토리메서드와 다를게 없는...abstract class User { public abstract String name(); public abstract String email();}class kakaoUser extends User{ private String name; private String email; public kakaoUser(String name, String email) { this.name = name; this.email = email; } @Override public String name() { return this.name; } @Override public String email() { return this.email; }}class googleUser extends User{ private String name; private String email; public googleUser(String name, String email) { this.name = name; this.email = email; } @Override public String name() { return this.name; } @Override public String email() { return this.email; }}추상팩토리의 역할을 하는 인터페이스 or 추상클래스가 필요interface AbstractOAuth2API { public User createUser();}class kakaoOauth2Factory implements AbstractOAuth2API { @Override public User createUser() { return new kakaoUser(\"홍길동\", \"카카오이메일\"); }}class googleOauth2Factory implements AbstractOAuth2API { @Override public User createUser() { return new googleUser(\"홍길동\", \"구글이메일\"); }}/*client 코드와의 접점이자 서브클래스를 생성하는데 도움주는 클래스*/class oauth2Factory{ public static User getUser(AbstractOAuth2API api) { return api.createUser(); }}public class codeTester { public static void main(String[] args) { User user1 = oauth2Factory.getUser(new kakaoOauth2Factory()); User user2 = oauth2Factory.getUser(new googleOauth2Factory()); System.out.println(user1.name()+\" \"+ user1.email()); System.out.println(user2.name()+\" \"+ user2.email()); }}//홍길동 카카오이메일//홍길동 구글이메일 장 단점 장점 재사용성이 좋다 * 구체적인 클래스를 분리하므로 서로가 달라도 어쨌든 묶여 있는 점에서 일관성이 있다.단점 새로운 인터페이스와 수많은 클래스가 패턴과 함께 도입되기 때문에 코드가 생각보다 복잡해질 수 있다. 결론 구현클래스에 의존하고 싶지않고 다양한 객체에 적용하고 싶을때 사용하자. 참고자료 Head First 디자인패턴면접을 위한 CS 전공지식노트" }, { "title": "LAMBDA?", "url": "/posts/lambda/", "categories": "Java, Syntax", "tags": "java, lambda", "date": "2022-12-28 19:41:57 +0900", "snippet": "What is Lambda?람다란? 메서드를 하나의 식으로 표현한 것. 익명함수 (Anonymous functions)와 같다.사용방법//평문int max(int a, int b){ return a&gt;b ? a : b;}//람다 (타입이 추론 가능할때 생략가능)(a,b) -&gt; { return a &gt; b ? a : b;} //리턴일때는 중괄호 생략 불가그밖에(int a) -&gt; a*a; = a-&gt; a*a; //매게변수 괄호 생략가능(String name, int i) -&gt; System.out.println(name+\"=\"+i) //중괄호 생략가능 함수형 인터페이스 (@functional interface)? 함수형 인터페이스는 람다식을 다루기 위한 인터페이스이다. 오직 하나의 추상 메서드만 정의되어 있어야 한다는 제약이 있다.그래야 람다식과 인터페이스의 메서드가 1대1로 연결된다.※ @FunctionalInterface는 컴파일러가 함수형 인터페이스를 올바르게 정의했는지 확인해주는 어노테이션이다.@FunctionalInterfaceinterface Function{ public abstract int max(int a , int b);}============================================Function f = (int a, int b) -&gt; a&gt;b ? a : b;int value = f.max(5,3); java.util.function 일반적으로 자주 쓰이는 형식의 메서드를 함수형 인터페이스로 미리 정의해놓은 패키지이다.주요 함수형 인터페이스 함수형 인터페이스 메서드 설명 java.lang.Runnable void run() 매개변수 X 반환값 x Supplier T get() 매개변수 X 반환값 O Consumer void accept(T t) 매개변수 O 반환값 X Function&lt;T,R&gt; R apply(T t) 매개변수O 반환값 O (일반적인 메서드) Predicate boolean test(T t) 매개변수 하나 반환값 boolean (조건식 표현) Predicate&lt;String&gt; some = s -&gt; s.length() == 0;String s =\"\";if(some.test(s)) // if(s.length()==0)랑 같다 sout(\"비어있다\")Supplier&lt;Integer&gt; s = ()-&gt; (int)(Math.random()*100)+1;Consumer&lt;Integer&gt; c = i -&gt;System.out.print(i);Function&lt;Integer,Integer&gt; f = i -&gt; i/10*10; // 일의자리 삭제하기Predicate&lt;Integer&gt; p = i%2 == 0;이를 이용해서 다양한 함수를 사용할 수 있다.매게변수가 두 개인 함수형 인터페이스 함수형 인터페이스 메서드 설명 BiConsumer&lt;T,U&gt; void accept(T t, U u) 두개의 매개변수 반환값 x BiPredicate&lt;T,U&gt; boolean test(T t, U u) 두개의 매개변수 반환값 boolean BiFunction&lt;T,U,R&gt; R apply(T t, U u) 두개의 매개변수 반환값 O Function의 변형 함수형 인터페이스 메서드 설명 UnaryOperator T apply(T t) function의 자손 BinaryOperator T apply(T t, T t) BiFunction의 자손 컬랙션 프레임워크 함수형 인터페이스 인터페이스 메서드 설명 Collection boolean removelf(Predicate filter) 조건에 맞는 요소를 삭제 List void replaceAll(UnarOperator operator) 모든요소를 반환하여 대체 Iterable void forEach(Consumer action) 모든 요소에 작업 action을 수행 Map V compute(K key, BiFunction&lt;K,V,V&gt;f) 지정된 키의 값에 작업 F를 수행   V computeIfAbsent(K key, Function&lt;K,V&gt;f) 키가 없으면 작업 f를 수행   V computeIfPresent(K key, BiFunction&lt;K,V,V&gt;f) 지정된 키가 있을 떄, 작업 f를 수행   V merge((K key, V value, BiFunction&lt;K,V,V&gt;f)) 모든 요소에 치환작업 병합작업 f를 수행   void forEach(BiConsumer&lt;K,V&gt; action) 모든 요소에 치환작업 작업 action을 수행   void replaceAll(BiFunction&lt;K,V,V&gt; f) 모든 요소에 치환작업 f를 수행 //list에 {1,2,3,4,5,6,7,8,9,10} 있다고 가정//map에는 [1,1],[2,2],[3,3]list.forEach(i-&gt; sout(i + \" \")); //{1,2,3,4,5,6,7,8,9,10}list.removeIf(x-&gt; x%2==0 || x%3==0); //{1,5,7}list.replaceAll(x-&gt;x*10); //{10,20,30,40,50,60,70...}map.forEach((k,v)-&gt;sout(k+\" \"+v))// 1 1 2 2 3 3 메서드 참조 람다식이 하나의 메서드만 호출하면 더 간단히 사용할 수 있다. 종류 람다 메서드 참조 Static 메서드 참조할 경우 (x)-&gt;className.method(x) className::method 인스턴스 메서드 참조할 경우 (obj,x)-&gt;obj.method(x) className::method 특정 객체 인스턴스메서드 참조할 경우 (x)-&gt;obj.method(x) obj::method 하나의 메서드만 호출하는 람다식은 클래스명::메서드명 or 참조변수::메서드명" }, { "title": "생성 패턴 - 프로토타입 패턴", "url": "/posts/prototype/", "categories": "CS, Design Pattern", "tags": "cs, design pattern", "date": "2022-12-26 15:10:57 +0900", "snippet": "Prototype Method Pattern 🧙‍♂️ 디자인 패턴이란? 디자인 패턴이란? 디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제를 자주 쓰이는 설계 방법을 정리한 패턴이다. 디자인 패턴을 참고하여 개발하면 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화가 된다고 한다.　 디자인 패턴을 목적과 범위로 나눌수 있다 구분 유형 설명   생성 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행 목적 구조 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴   행위 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 범위 클래스 클래스간 관련성(상속), 컴파일 시 정적으로 결정   객체 객체 간 관련성을 다루는 패턴, 런타임 시 동적으로 결정 　　 기존 객체를 복제함으로써 객체를 생성하여 DB,네트워크 접근 비용을 절감하는 패턴 프로토타입 패턴이란? 처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴이다.생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며, 객체를 생성할 때나,갖추어야 할 기본형태가 있을 때, 사용되는 패턴이다.public class Employees implements Cloneable { private List&lt;String&gt; nameList; public Employees() { this.nameList = new ArrayList&lt;&gt;(); } public Employees(List&lt;String&gt; list) { this.nameList = list; } public void uploadData() { nameList.add(\"Kim\"); nameList.add(\"Park\"); nameList.add(\"Lee\"); } //핵심 내용 @Override public Object clone() throws CloneNotSupportedException { List &lt;String&gt; temp = new ArrayList &lt; &gt; (); for (String str: this.nameList) { temp.add(str); } return new Employees(temp); }} public class PrototypePattern { public static void main(String[] args) throws CloneNotSupportedException { Employees employees = new Employees(); employees.uploadData(); // Kim, Park, Lee Employees employees1 = (Employees) employees.clone(); Employees employees2 = (Employees) employees.clone(); List &lt; String &gt; list1 = employees1.getList(); list1.add(\"Na\"); List &lt; String &gt; list2 = employees2.getList(); list2.remove(\"Lee\"); System.out.println(\"employees: \" + employees.getList()); System.out.println(\"employees 1: \" + list1.getList()); System.out.println(\"employees 2: \" + list2.getList()); }}/** employees : Kim, Park ,Lee* employees 1: Kim, Park ,Lee, Na* employees 2: Kim, Park*/Clone 메소드를 통해 DB로부터 한번의 호출을 통해서 데이터를 조작할 수 있었다. 장 단점 장점 객체를 생성해주기 위한 별도의 객체 생성 클래스가 필요하지 않다. 비용절감단점 생성해야할 객체들의 클래스들을 모두 clone()메서드로 구현해야함. 결론 데이터를 바꾸고 저장하는 과정이 한번에 일어난다고 가정하면, 이러한 방법으로 속도를 향상 시키자.객체를 복사하는 것이 네트워크 접근이나 DB 접근보다 훨씬 비용이 적다. 참고자료 Head First 디자인패턴면접을 위한 CS 전공지식노트" }, { "title": "생성 패턴 - 팩토리 메서드 패턴", "url": "/posts/factory-method/", "categories": "CS, Design Pattern", "tags": "cs, design pattern", "date": "2022-12-26 15:10:57 +0900", "snippet": "Factory Method Pattern 디자인 패턴이란? 디자인 패턴이란? 디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제를 자주 쓰이는 설계 방법을 정리한 패턴이다. 디자인 패턴을 참고하여 개발하면 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화가 된다고 한다.　 디자인 패턴을 목적과 범위로 나눌수 있다 구분 유형 설명   생성 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행 목적 구조 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴   행위 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 범위 클래스 클래스간 관련성(상속), 컴파일 시 정적으로 결정   객체 객체 간 관련성을 다루는 패턴, 런타임 시 동적으로 결정 　　 생성할 객체의 클래스를 국한하지 않고 생성한다. 추상 팩토리와의 차이: 팩토리 패턴은 한 종류의 객체를 생성하기 위해 사용되지만,추상 팩토리 패턴은 연관되거나 의존적인 객체로 이루어진 여러 종류의 객체를 생성하기 위해 사용된다. 팩토리 메서드 패턴이란? 상위클래스에서는 인스턴스를 만드는 방법을 결정하고,하위 클래스에서는 데이터의 생성을 책임지고 조작하는 함수들을 오버라이딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특징을 갖는 디자인 패턴. 팩토리 메소드 패턴 헤드 퍼스트 Productinterface Pizza { public void prepare(); public void bake(); public void box();}Creatorabstract class PizzaStore { public Pizza orderPizza(String type) { Pizza pizza = createPizza(type); // factory method 사용 pizza.prepare(); pizza.bake(); pizza.box(); return pizza; } abstract Pizza createPizza(String type); // factory method extends하면 필수구현}/*뉴욕 피자*/class NYPizzaStore extends PizzaStore { @Override Pizza createPizza(String type) { if (\"cheese\".equals(type)) { return new NYStyleCheesePizza(); } else if (\"pepperoni\".equals(type)) { return new NYStylePepperoniPizza(); } return null; }}/*시카고 피자*/class ChicagoPizzaStore extends PizzaStore { @Override Pizza createPizza(String type) { if (\"cheese\".equals(type)) { return new ChicagoStyleCheesePizza(); } else if (\"pepperoni\".equals(type)) { return new ChicagoStylePepperoniPizza(); } return null; }}Mainpsvm(){ PizzaStore nyStore = new NYPizzaStore(); PizzaStore chicagoStore = new ChicagoPizzaStore(); Pizza pizza = nyStore.orderPizza(\"cheese\"); Pizza pizza1 = chicagoStore.orderPizza(\"pepperoni\");}위 처럼 추상클래스의 특징인 상속을 통해 자손 클래스에서 완성을 유도하는 방식으로(미완성 설계도) 구현한 패턴이다. 장 단점 장점 OCP와 DIP를 잘 지킴 느슨한 결합도 유지단점 자식 클래스가 많아지면서 코드가 복잡해질 가능성이 있음 결론 팩토리 메소드 패턴은 클래스간의 결합도를 낮추기 위함이다.객체를 직접 생성해서 사용하는 것을 방지하고 서브 클래스에 위임해서 효과적인 코드제어와 의존성을 제거함이다. 참고자료 참고 자료 Head First 디자인패턴면접을 위한 CS 전공지식노트" }, { "title": "생성패턴 - 싱글톤 패턴", "url": "/posts/singleton/", "categories": "CS, Design Pattern", "tags": "cs, design pattern", "date": "2022-12-22 12:15:07 +0900", "snippet": "Singleton Pattern 디자인 패턴이란? 디자인 패턴이란? 디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제를 자주 쓰이는 설계 방법을 정리한 패턴이다. 디자인 패턴을 참고하여 개발하면 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화가 된다고 한다.　 디자인 패턴을 목적과 범위로 나눌수 있다 구분 유형 설명   생성 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행 목적 구조 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴   행위 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 범위 클래스 클래스간 관련성(상속), 컴파일 시 정적으로 결정   객체 객체 간 관련성을 다루는 패턴, 런타임 시 동적으로 결정 　　 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인패턴데이터베이스 연결 모듈에서 많이 쓰이는 패턴이다. 싱글톤 패턴이란? 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에 서든지 참조 할 수있도록 하는 디자인 패턴public class SingletonService(){ private static final SingletonService instance = new SingletonService(); public static SingletonService getInstance(){ return instance; } private SingletonService(){ } public void logic(){ //로직 }}// 다른 클래스public static void main(String[] args){ ... = new SingletonService() // 생성자가 private이기에 막을 수 있다.}위의 코드처럼 client가 요청할 때마다 객체를 생성하는것이 아닌, 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다. 다만 수많은 문제점들이 있다. 장점과 단점 장점 객체보장 객체공유단점 기본 셋팅 코드가 많이 들어간다. (1번부터 15번 라인까지) DIP, OCP 위반한다. *의존 관계상 클라이언트가 구현 클래스를 의존함 단위 테스트를 하기 어렵다. 각각의 테스트마다 독립적인 인스턴스를 만들기 어려움 내부 속성을 변경하거나 초기화 하기 어렵다 아니 그럼 왜 이렇게 문제가 많은데 왜 쓰는거지? -&gt; 의존성 주입 (feat. 싱글톤 컨테이너!!) 메인 모듈이 직접 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입(DI)을 통해 메인 모듈이 간접적으로 의존성을 주입하는 방식. `디커플링` 이라고도 한다. 의존성 주입의 장점: 모듈 간의 테스트를 쉽게하고 의존성 방향이 일관되고 관계가 명확해짐 단점: 클래스 수가 늘어나 복잡해지고 약간의 런타임 패널티가 생김스프링 컨테이너는 위에 언급한 문제점을 해결하면서 싱글톤의 장점을 살린다. `스프링 빈을 싱글톤 패턴으로 관리` 김영한 강의 자료중 일부 발췌 위의 그림처럼 싱글톤의 장점을 볼 수 있다.　　 　 결론 싱글톤 패턴은 안티패턴이라는 말이 있듯이 단독으로 사용되면 OOP설계를 위반하기 쉽다.하지만 위에서 소개한 내용대로 스프링 컨테이너의 도움을 받으면 싱글톤 패턴의 단점을 보완하면서 사용할 수 있다.*스프링 빈은 컨테이너의 도움을 받아 싱글톤 스콥으로 관리되고 있는걸 확인 할 수 있다. 참고자료 인프런 김영한 스프링 기본 강의" }, { "title": "생성패턴 - 빌더 패턴", "url": "/posts/builder/", "categories": "CS, Design Pattern", "tags": "cs, design pattern", "date": "2022-12-19 23:11:07 +0900", "snippet": "Builder Pattern 디자인 패턴이란? 디자인 패턴이란? 디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제를 자주 쓰이는 설계 방법을 정리한 패턴이다. 디자인 패턴을 참고하여 개발하면 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화가 된다고 한다.　 디자인 패턴을 목적과 범위로 나눌수 있다 구분 유형 설명   생성 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행 목적 구조 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴   행위 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 범위 클래스 클래스간 관련성(상속), 컴파일 시 정적으로 결정   객체 객체 간 관련성을 다루는 패턴, 런타임 시 동적으로 결정 　　 복잡한 객체를 생성할떈 setter, new 대신 빌더를 이용해서 생성과 표기를 분리하자! 빌더 패턴이란? 복잡한 인스턴스를 조립하여 만드는 구조로써 복합한 객체를 생성할때,객체를 생성하는 과정과 객체를 구현하는 방법을 분리함으로써,동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴이다.필자는 StringBuilder를 통해 간접적으로? 쓰고 있었던 패턴이다.개발을 하다보면 유저에 포함된 정보가 엄청 많이 들어가진다. 그러다보면 필드값만 10가지가 넘는경우가 허다하다.그렇다고 유저를 생성할떄마다 필드값 전부를 다 쓰지않는다. email을 저장해도 되고 안해도 된다는 상황이 있다고 가정해보자.이럴 경우 생성자나 정적메소드를 이용하는 경우에는 필요할 떄마다 생성자를 만들거나 email에 의미없는 값을 넣어줘야한다.순서로부터 상관없는 Setter를 써도 되지만 불필요하게 확장 가능성을 열어두기에 SOLID원칙인 Open-Closed 법칙에 위배된다.그러므로 클래스 변수는 final로 객체 생성은 빌더를 사용하는게 좋다. //생성자 호출보단Member member = new Member(\"name\", age, height, email);//Setter 보단member.setName(\"name\"); member.setAge(age); Member member = member.builder() .name(\"name\") .age(age) ...//생략 이런식의 빌더를 쓰자! 결론 필요한 데이터만 설정가능하다 가독성 향상 유연성 불변성하지만 주로 웹 개발시, 엔티티 객체 또는 도메인객체로 DTO를 생성해서 다루기에 직접 빌더를 만들고 하는 작업이 번거로우니 MapStruct나 Model mapper에게 생성을 위임하자 참고자료 Head First 디자인패턴면접을 위한 CS 전공지식노트" }, { "title": "구조패턴 - 컴포지트 패턴", "url": "/posts/composite/", "categories": "CS, Design Pattern", "tags": "cs, design pattern", "date": "2022-12-12 15:11:04 +0900", "snippet": "Composite Pattern 디자인 패턴이란? 디자인 패턴이란? 디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제를 자주 쓰이는 설계 방법을 정리한 패턴이다. 디자인 패턴을 참고하여 개발하면 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화가 된다고 한다.　 디자인 패턴을 목적과 범위로 나눌수 있다 구분 유형 설명   생성 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행 목적 구조 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴   행위 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 범위 클래스 클래스간 관련성(상속), 컴파일 시 정적으로 결정   객체 객체 간 관련성을 다루는 패턴, 런타임 시 동적으로 결정 　 하나의 operation을 사용할때 client는 Component에 있는 operation만 쓰면된다. 컴포지트 패턴이란? 객체들의 관계를 트리구조로 구성하여 부분 - 전체 계층을 표현하는 패턴으로 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴이다. 아래의 예제는 복합객체와 단일객체를 동일하게 취급하는 경우를 나타냈다.//기본 요소(basic component) 두개의 leaf가 필요로하는 메서드public interface Department { void printDepartmentName();}// LEAFS 1@RequiredConstructor @Getter @Setterpublic class FinancialDepartment implements Department { private Integer id; private String name; public void printDepartmentName() { System.out.println(getClass().getSimpleName()); } }// LEAFS 2@RequiredConstructor @Getter @Setterpublic class SalesDepartment implements Department { private Integer id; private String name; public void printDepartmentName() { System.out.println(getClass().getSimpleName()); }}복합 요소(Composite Element)public class HeadDepartment implements Department { private Integer id; private String name; private List&lt;Department&gt; childDepartments; public HeadDepartment(Integer id, String name) { this.id = id; this.name = name; this.childDepartments = new ArrayList&lt;&gt;(); } public void printDepartmentName() { childDepartments.forEach(Department::printDepartmentName); } public void addDepartment(Department department) { childDepartments.add(department); } public void removeDepartment(Department department) { childDepartments.remove(department); }}public class CompositeDemo { public static void main(String args[]) { Department salesDepartment = new SalesDepartment( 1, \"Sales department\"); Department financialDepartment = new FinancialDepartment( 2, \"Financial department\"); HeadDepartment headDepartment = new HeadDepartment( 3, \"Head department\"); headDepartment.addDepartment(salesDepartment); headDepartment.addDepartment(financialDepartment); headDepartment.printDepartmentName(); }}// SalesDepartment와 FinacialDepartment가 출력된다.위에는 계층구조로 된 회사 조직도를 코드로 나타낸것이다.재정부서, 판매부서, HR 이렇게 3곳을 나타냈다.HR은 복합, 재정,판매는 단일객체의 형태를 띄고있다. 즉, 단일객체와 복합객체를 구분하지않고 동일한 형태로 사용할때의 예시이다.아래의 main쪽을 보면 코드가 단순해지고 객체들이 모두 같은 타입으로 취급되므로 새로운 클래스를 쉽게 추가 할 수 있다.다만, 지나치게 범용성을 가진다면 이를 제어하기 어려워질 수가 있다. 결론 객체들 간에 계급 및 계층구조가 있고 이를 표현해야할 경우 클라이언트가 단일 객체와 집합 객체를 구분하지 않고 동일한 형태로 사용하고자 할 경우 개방 폐쇄 원칙을 지킬 수 있다. 참고자료 Source ⅠHead First 디자인패턴면접을 위한 CS 전공지식노트—" }, { "title": "구조패턴 - 플라이웨이트 패턴", "url": "/posts/flyweight/", "categories": "CS, Design Pattern", "tags": "cs, design pattern", "date": "2022-12-05 15:11:04 +0900", "snippet": "flyweight Pattern 디자인 패턴이란? 디자인 패턴이란? 디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제를 자주 쓰이는 설계 방법을 정리한 패턴이다. 디자인 패턴을 참고하여 개발하면 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화가 된다고 한다.　 디자인 패턴을 목적과 범위로 나눌수 있다 구분 유형 설명   생성 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행 목적 구조 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴   행위 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 범위 클래스 클래스간 관련성(상속), 컴파일 시 정적으로 결정   객체 객체 간 관련성을 다루는 패턴, 런타임 시 동적으로 결정 　 다수의 인스턴스를 가능한대로 공유시켜서 new처럼 불필요한 생성을 막아 메모리 낭비 최소화 100만원이 있는데 구매하고자 하는 메모리 점퍼가 120만원이다.점퍼를 매일 입지않는이상 60씩 지불하고 같이 돌려입으면된다.　　 플라이웨이트 패턴이란? 다수의 객체가 생성되는 경우(new Class) 모두가 갖는 본질적인 요소를 클래스화해서 공유함으로써 메모리를 절약하고,클래스의 경량화를 목적으로 하는 디자인 패턴이다. 여러개의 가상 인스턴스를 제공하여 메모리 절감을 함. 　　TreeType은 Tree 클래스에서 반복되는 상태를 추출한 클래스TreeFactory는 기존 TreeType을 사용할지 새로운 객체를 생성할지 결정하는 공간.Tree와 Forest는 flyweight의 클라이언트이며, Tree를 변경할 계획이 없으면 병합해도 된다.같은 데이터를 여러 객체에 저장하는 방법 대신에 몇개의 플라이웨이트 객체들에 보관해서 메모리를 효율적으로 운용하는 방식의 패턴 결론 프로그램이 많은 수의 객체들을 지원해야하는데 RAM이 꽉 찼을때 쓸만한 패턴 앱이 수많은 유사 객체들을 생성해야 할 경우 장치에서 사용할 수 있는 모든 RAM을 소모할 경우 여러 중복 상태들이 포함되어 있으며, 추출된 후 객체 간에 공유될 수 있을 경우 참고자료 Source ⅠHead First 디자인패턴면접을 위한 CS 전공지식노트—" }, { "title": "구조패턴 - 데코레이터 패턴", "url": "/posts/decorator/", "categories": "CS, Design Pattern", "tags": "cs, design pattern", "date": "2022-11-30 15:11:04 +0900", "snippet": "Decorator Pattern 디자인 패턴이란? 디자인 패턴이란? 디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제를 자주 쓰이는 설계 방법을 정리한 패턴이다. 디자인 패턴을 참고하여 개발하면 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화가 된다고 한다.　 디자인 패턴을 목적과 범위로 나눌수 있다 구분 유형 설명   생성 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행 목적 구조 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴   행위 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 범위 클래스 클래스간 관련성(상속), 컴파일 시 정적으로 결정   객체 객체 간 관련성을 다루는 패턴, 런타임 시 동적으로 결정 　 객체의 결합을 통해 기능을 동적으로 유연하게 확장(주요 기능에 무엇인가를 추가)신발끈 색만 바꾸고 싶을 때, 똑같은 신발을 살 필요 없이 신발끈만 사서 바꾸면 된다. Proxy 패턴과의 차이: 주요기능을 다양한 방식으로 컨트롤 해주는 것 데코레이터 패턴이란? 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 설계 패턴으로써 기능확장이 필요할 때,객체간의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주어 상속의 대안으로 사용하는 디자인 패턴이다. 데코레이터 패턴의 예 - Baeldung 　　위의 그림구조는 런타임에 원하는 만큼 데코레이터를 추가할 수 있는 유연성을 제공한다.기존의 장신구들이 있다면 굳이 트리를 살때, 똑같은 장신구를 살 필요없듯이 인터페이스로 받아서 사용하는 패턴이다.기본 윈도우interface Window { public void draw(); // draws the Window public String getDescription(); // returns a description of the Window}class SimpleWindow implements Window { public void draw() { } public String getDescription() { return \"simple window\"; }}데코레이터 클래스// abstract decorator class - note that it implements Windowabstract class WindowDecorator implements Window { protected Window decoratedWindow; // the Window being decorated public WindowDecorator (Window decoratedWindow) { this.decoratedWindow = decoratedWindow; }}// 첫번째 데코레이터 패턴 수직스크롤기능 추가class VerticalScrollBarDecorator extends WindowDecorator { public VerticalScrollBarDecorator (Window decoratedWindow) { super(decoratedWindow); } public void draw() { drawVerticalScrollBar(); decoratedWindow.draw(); } private void drawVerticalScrollBar() { // draw the vertical scrollbar } public String getDescription() { return decoratedWindow.getDescription() + \", including vertical scrollbars\"; }}// 두번째 데코레이터 패턴 수평스크롤 기능 추가class HorizontalScrollBarDecorator extends WindowDecorator { public HorizontalScrollBarDecorator (Window decoratedWindow) { super(decoratedWindow); } public void draw() { drawHorizontalScrollBar(); decoratedWindow.draw(); } private void drawHorizontalScrollBar() { // draw the horizontal scrollbar } public String getDescription() { return decoratedWindow.getDescription() + \", including horizontal scrollbars\"; }}데코레이터 패턴이 적용된 객체 호출public class DecoratedWindowTest { public static void main(String[] args) { // create a decorated Window with horizontal and vertical scrollbars Window decoratedWindow = new HorizontalScrollBarDecorator ( new VerticalScrollBarDecorator(new SimpleWindow())); }} 결론 객체에 단순히 동작이나 상태를 CRUD할 경우 클래스의 하나의 object 기능을 수정하고 다른 개체는 변경 할 필요 없을 경우 참고자료 Source ⅠSource ⅡHead First 디자인패턴면접을 위한 CS 전공지식노트—" }, { "title": "구조패턴 - 브릿지 패턴", "url": "/posts/Bridge/", "categories": "CS, Design Pattern", "tags": "cs, design pattern", "date": "2022-11-23 18:21:07 +0900", "snippet": "Bridge Pattern 디자인 패턴이란? 디자인 패턴이란? 디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제를 자주 쓰이는 설계 방법을 정리한 패턴이다. 디자인 패턴을 참고하여 개발하면 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화가 된다고 한다.　 디자인 패턴을 목적과 범위로 나눌수 있다 구분 유형 설명   생성 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행 목적 구조 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴   행위 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 범위 클래스 클래스간 관련성(상속), 컴파일 시 정적으로 결정   객체 객체 간 관련성을 다루는 패턴, 런타임 시 동적으로 결정 　 기존의 시스템에 부수적인 새로운 기능을 추가할떄 사용하는 패턴하나의 클래스, 메서드를 통해서 징검다리 역할 브릿지 패턴이란? 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴구현뿐만 아니라, 추상화된 부분까지 변경해야하는 경우 활용할 수 있다. 브릿지 패턴의 예 - Baeldung 　　세모와 네모는 다른 생김새지만 Shape이라는 특징이 같다. 그러므로 Shape으로 묶고 색상도 색은 다르지만 Color로 묶음으로써 사용자는 원하는 shape과 color를 사용할 수 있게 하는 구조이다.색 관련 코드public interface Color { String fill();}public class Red implements Color { @Override public String fill() { return \"발간색\"; }}public class Blue implements Color { @Override public String fill() { return \"파란색\"; }}그리는 툴 추상클래스public abstract class Brush { protected Color color; protected Brush(Color color) { this.color = color; } public abstract String draw(); }public class HBPencil extends Brush { public static final String type = \"[연필]\"; public HBPencil(Color color) { super(color); } @Override public String draw() { return type + \" \" + color.fill(); }}public class MonoLine extends Brush { public static final String type = \"[붓]\"; public MonoLine(Color color) { super(color); } @Override public String draw() { return type + \" \" + color.fill(); }}메인 테스트 코드class BrushTest { @Test @DisplayName(\"브리지 패턴 테스트\") void brushColorTest() { Brush redBrush = new HBPencil(new Red()); Assertions.assertThat(\"[연필] 빨간색\".equals(redBrush.draw())); Brush blueBrush = new MonoLine(new Blue()); Assertions.assertThat(\"[붓] 파란색\".equals(blueBrush.draw())); }} 결론 부모 추상클래스가 규칙을 정의할수 있고, 클래스에 규칙을 추가하고 싶을 경우 객체에 대한 참조가 있는 추상클래스가 있고, 각각의 클래스에서 정의될 추상 메서드가 있는 경우 참고자료 Source ⅠHead First 디자인패턴면접을 위한 CS 전공지식노트—" }, { "title": "구조패턴 - 어댑터 패턴", "url": "/posts/adapter/", "categories": "CS, Design Pattern", "tags": "cs, design pattern", "date": "2022-11-16 21:21:07 +0900", "snippet": "Adapter Pattern 디자인 패턴이란? 디자인 패턴이란? 디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제를 자주 쓰이는 설계 방법을 정리한 패턴이다. 디자인 패턴을 참고하여 개발하면 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화가 된다고 한다.　 디자인 패턴을 목적과 범위로 나눌수 있다 구분 유형 설명   생성 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행 목적 구조 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴   행위 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 범위 클래스 클래스간 관련성(상속), 컴파일 시 정적으로 결정   객체 객체 간 관련성을 다루는 패턴, 런타임 시 동적으로 결정 　 기존의 시스템에 새로운 써드파티 라이브러리를 추가하거나 레거시 인터페이스를 새로운 인터페이스로 교체하는 경우다른 인터페이스를 자신의 인터페이스 스타일로 변경하겠다. Facade 패턴과의 차이: 복잡한 기능을 중간에서 감추고 심플하게 단방향 통신하겠다 어댑터 패턴이란? 해외 여행 어댑터 우리가 해외여행을 가면 220V를 110V에 바로 전기를 꼽지못하지만 사용할 수 있도록 도와주는 친구가 어댑터다.이 개념을 똑같이 코드에 가져가서 생각하면된다. 상황 Object 어뎁터 Client는 Target 인터페이스를 구현한 Adaptee가 필요하다.Adaptee는 Target인터페이스를 구현하지 않고 있다.Adaptee는 이미 개발이 완료되어 사용중이다.Adaptee를 변경하는 것이 적절하지 않은 상황이다.// Adaptee는 이미 개발이 완료되어 사용중이고 변경하는 것이 적절하지 않음.public interface Plugin { public void connect();}public class Plugin220V implements Plugin { @Override public void connect() { System.out.println(\"220V\"); }해결 방법 (많은 사람들이 사용하는 방식인 Object Adapter 방식으로 구현)대부분의 코드를 구현해야하지만 Composition을 사용하기에 유연함으로 많은사람이 채택함.Adapter// 어뎁터 클래스를 만든다.public interface PluginAdapter { public void connect();}clientpublic class Adapter110V implements PluginAdapter { private Plugin plugin;\t public Adapter110V(Plugin plugin) { this.plugin=plugin; } @Override public void connect() { System.out.println(\"110v convert\"); this.plugin.connect(); }//mainpublic class AdapterPattern { public static void main(String[] args) { PluginAdapter plugin = new Adapter110V(new Plugin220V()); plugin.connect(); }}기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴으로써상속을 이용하는 클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두 가지 형태로 사용되는 디자인 패턴이다.인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 다른 클래스의 인터페이스를 기존 인터페이스에 덧씌운다.Class 어댑터에서는 어댑터를 만들 때 타겟과 어댑티 모두의 서브 클래스로 만들고,Object 어댑터 에서는 구성을 통해서 어댑티에 요청을 전달한다는 점을 제외하면 별다른 차이점이 없다 결론 변경할 수 없는 내부 구현, 라이브러리 등에 추가적인 기능을 만들고 싶을 때 유용하게 활용할 수 있다.사용해야하는 인터페이스가 현재의 시스템과 호환되지 않는다고 해서 굳이 현존하는 시스템을 호환되도록 변경할 필요는 없다. 참고자료 Source ⅠHead First 디자인패턴면접을 위한 CS 전공지식노트" }, { "title": "구조패턴 - 파사드 패턴", "url": "/posts/fasade/", "categories": "CS, Design Pattern", "tags": "cs, design pattern", "date": "2022-11-07 20:11:07 +0900", "snippet": "Facade Pattern 🧙‍♂️ 디자인 패턴이란? 디자인 패턴이란? 디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제를 자주 쓰이는 설계 방법을 정리한 패턴이다. 디자인 패턴을 참고하여 개발하면 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화가 된다고 한다.　 디자인 패턴을 목적과 범위로 나눌수 있다 구분 유형 설명   생성 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행 목적 구조 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴   행위 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 범위 클래스 클래스간 관련성(상속), 컴파일 시 정적으로 결정   객체 객체 간 관련성을 다루는 패턴, 런타임 시 동적으로 결정 　　 Problem 프로젝트 때, 하나의 메서드에서 여러가지 객체들을 호출하는 구조가 있었다.그러다보니, 코드의 가독성이 떨어지고 여러 객체들이 의존성을 갖게 되기 떄문에 문제가 발생되었다. 이를 해결하기 위해 파사드 패턴을 도입했다. 입금만 가능한 기계, 출금만 가능한 기계가 있는게 아니듯이 하나의 ATM기에서 여러 일을 처리하는 것 Adapter 패턴과의 차이: 다른 인터페이스를 자신의 인터페이스 스타일 대로 변경 파사드 패턴이란? 출처- 나무위키 　　파사드 패턴은 하위 객체들을 쉽게 사용할 수 있도록 고수준 객체를 만들어서 문제를 해결하는 패턴이다.복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템 간의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴으로 오류에 대해서 단위별로 확인 할 수있게 하며, 사용자의 측면에서 단순한 인터페이스 제공을 통해 접근성을 높일 수 있는 디자인 패턴이다. 해당 내용을 이해하기 위해 아래의 코드를 보자./* 저수준 하위 객체들 */class CPU {\tpublic void freeze() { ... }\tpublic void jump(long position) { ... }\tpublic void execute() { ... }}class Memory {\tpublic void load(long position, byte[] data) {\t\t...\t}}class HardDrive {\tpublic byte[] read(long lba, int size) {\t\t...\t}}/* 파사드 역할 */class Computer {\tpublic void startComputer() { CPU cpu = new CPU(); Memory memory = new Memory(); HardDrive hardDrive = new HardDrive();\t\tcpu.freeze();\t\tmemory.load(BOOT_ADDRESS, hardDrive.read(BOOT_SECTOR, SECTOR_SIZE));\t\tcpu.jump(BOOT_ADDRESS);\t\tcpu.execute();\t}}/* Client */class Client {\tpublic static void main(String[] args) throws ParseException {\t\tComputer facade = /* 파사드 인스턴스 */;\t\tfacade.startComputer();\t}} 클라이언트가 파사드(컴퓨터)를 통해서 컴퓨터를 제어하는 예제이다. 　　이처럼 하나의 클래스로 저수준의 객체를 모아서 관리하므로써 클라이언트는 컴퓨터만 신경쓰면 되는 구조로 바뀌었다. 필요한 기능만 들어간 단순한 인터페이스를 구현함으로써 문제발생이 줄어듬과 동시에 코드가 명료해진다.다만, 잦은 파사드 패턴은 하나로 모아 관리하는 객체가 복잡해진다는 것이다. 따라서 무조건적으로 넣는게 아닌 저수준의 객체들도 최대한 간단하게 설계해서 만들어야 파사드 패턴의 이점을 가져갈 수 있다.　 참고자료 Head First 디자인패턴면접을 위한 CS 전공지식노트" }, { "title": "Basic Confusing Questions Ⅱ 🤷‍♂️ (17개)", "url": "/posts/java-basic-2/", "categories": "CS, Questions", "tags": "cs, questions", "date": "2022-11-06 19:20:57 +0900", "snippet": "Basic Confusing Questions Ⅱ 🤷‍♂️ 클릭하면 정답이 나옵니당~자바의 정석(남궁성 지음)에서 인용한 코드와 내용을 담고 있습니다. REST API란 무엇인가요?\t 기본형 변수의 실제 데이터를 저장참조형 주소값의 데이터를 저장한다. 자바는 C와 다르게 참조형 변수끼리 연산이 안된다. DNS의 정의와 DNS가 필요한 이유에 대해 설명해주세요.\t\t URL과 URI의 차이점이 무엇인가요?\t 웹 브라우저에서 CORS 이슈가 발생하는 원인은 무엇이며, 서버에서 어떻게 해결할 수 있나요? 이진 탐색 알고리즘(BST)이 데이터를 효율적으로 찾기 위해 탐색하는 과정을 설명해주세요.\t 탐욕(Greedy) 알고리즘을 사용하기 위해 성립해야 하는 조건에 대해 설명해주세요. 인접 행렬과 인접 리스트의 차이점은 무엇인가요?\t\t Stack과 Queue의 차이점에 대해 설명해주세요.\t DI(Dependency Injection)에 대한 설명과 해당 기술의 장점\t 스프링 컨테이너(Spring Container)에 대해 설명 Spring에서 AOP가 필요한 이유에 대해 설명 Foreign Key와 Primary Key에 대해 설명 트랜잭션에 대해 설명 Client Side Rendering 과 Server Side Rendering 의 차이점에 대해서 설명 재귀 함수와 반복문의 차이점에 대해 설명 @component, @Configuration 차이\t 다이나믹 알고리즘을 사용하기 위한 성립 조건에 대해 말해줘\t " }, { "title": "구조패턴 - 프록시 패턴", "url": "/posts/proxy/", "categories": "CS, Design Pattern", "tags": "cs, design pattern", "date": "2022-11-02 15:10:57 +0900", "snippet": "Proxy Pattern 디자인 패턴이란? 디자인 패턴이란? 디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제를 자주 쓰이는 설계 방법을 정리한 패턴이다. 디자인 패턴을 참고하여 개발하면 효율성과 유지보수성, 운용성이 높아지며, 프로그램 최적화가 된다고 한다.　 디자인 패턴을 목적과 범위로 나눌수 있다 구분 유형 설명   생성 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행 목적 구조 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴   행위 클래스나 객체들이 상호작용하는 방법과 역할 분담을 다루는 패턴 범위 클래스 클래스간 관련성(상속), 컴파일 시 정적으로 결정   객체 객체 간 관련성을 다루는 패턴, 런타임 시 동적으로 결정 　　 프록시 패턴이란? 구조 패턴 중 하나로 실체 객체에 대한 대리 객체로 실체 객체에 대한 접근 이전에 필요한 행동을 취할수 있게 만들어준다. 이 점을 이용해서 미리 할당하지 않아도 상관없는 것들을 실제 이용할때 할당하게 하여 메모리용량을 아낄 수 있으며 실체 객체를 드러나지 않게 하여 정보은닉의 역할도 수행하는 디자인 패턴이다. 프록시? 일종의 대리자이자 비서 (주요기능을 다양한 방식으로 컨트롤 해주는 것)팀장님한테 바로 보고하는게 아니라 사수한테 먼저 물어보는 방식 Decorator 패턴과의 차이: 주요기능에 기능을 추가하는 것 프록시 패턴 from wiki 대표적인 프록시 가상 프록시 : 프록시 클래스에서 자잘한 작업들을 처리하고 리소스가 많이 요구되는 작업들이 필요할 때에만 주체 클래스를 사용하도록 구현e.g) 해상도가 아주 높은 이미지를 처리해야 하는 경우 작업을 분산처리 　　 - 용량이 큰 이미지와 글이 있는 문서를 화면에 띄울떄, 텍스트를 먼저 불러오고 이미지는 추후처리 원격 프록시: 서로 다른 주소 공간에 있는 객체에 대해 마치 같은 주소 공간에 있는 것처럼 동작하는 방식. e.g) google Docs 브라우저는 브라우저대로 필요한 자원을 로컬에 가지고 있고 또다른 자원은 Google 서버에 있는 형태 보호 프록시: 객체에 대한 접근 권한을 제어하거나 객체마다 접근 권한을 달리하고 싶을때 사용하는 방식.e.g) 권한을 가진 사용자만이 정보열람을 할 수 있는 프로그램이는 SOLID의 OCP(open closed principle), DIP (Dependency Inversion principle)의 설계원칙을 적용한 패턴으로 볼 수있다.실제 이미지public interface Image { void displayImage();}public class Real_Image implements Image { private String fileName; public Real_Image(String fileName) { this.fileName = fileName; loadFromDisk(fileName); } private void loadFromDisk(String fileName) { System.out.println(\"Loading \" + fileName); } @Override public void displayImage() { System.out.println(\"Displaying \" + fileName); }}프록시 이미지public class Proxy_Image implements Image { private Real_Image realImage; private String fileName; public Proxy_Image(String fileName) { this.fileName = fileName; } @Override public void displayImage() { if (realImage == null) { realImage = new Real_Image(fileName); } realImage.displayImage(); }}//mainpublic class Proxy_Main { public static void main(String[] args) { Image image1 = new Proxy_Image(\"test1.png\"); Image image2 = new Proxy_Image(\"test2.png\"); image1.displayImage(); System.out.println(); image2.displayImage(); }} 장 단점 장점 사이즈가 큰 이미지(객체)가 로딩되기 전에도 프록시를 통해 참조가능 실제 객체의 public, protected 메소드들을 숨기고 인터페이스를 통해 사용가능 로컬에 있지않은 객체,메소드를 사용할 수 있다. 객체의 접근에 대해 사전 처리가능.단점 객체를 생성할때 한 단계를 더 수행하기 떄문에, 자주 사용 시 성능저하 가독성 저하 프록시 내부에서 객체 생성을 위해 스레드 생성, 동기화가 구현되어야하므로 성능저하 결론 직접 실행 메서드를 호출하는 것을 피하면서 흐름을 제어하는데 큰 도움을 주는 패턴이다. 참고자료 코드 자료Head First 디자인패턴면접을 위한 CS 전공지식노트" }, { "title": "AOP", "url": "/posts/Aop/", "categories": "Java, Spring", "tags": "java, spring", "date": "2022-10-26 13:52:57 +0900", "snippet": "“AOP? 횡단관심사?” 사용하게 된 계기 토이 프로젝트에서 여러명이서 각기 다른 컨트롤러를 개발하다보니 컨트롤러 단에서 중복되는 불필요한 코드가 많아졌다.또한, 컨트롤러에서 핵심로직에 대한 가독성이 떨어지는 결과가 나타났다.　 서로 다른 컨트롤러 끼리 묶음 　위와 같이 서로 다른 컨트롤들에 공통적으로 필요한 기능들을 횡단관심사로 묶어서 AOP기술을 사용했다.토큰으로부터 얻고자하는 관심사를 묶고 컨트롤러 앞단에서 해당 로직을 처리하여 컨트롤러에서 보내주도록 리팩토링했고그 결과 컨트롤러에 불필요한 코드가 줄어들고 파라미터 또한 줄어들어, 작업속도 좋은 영향을 주었다.　 어노테이션으로 묶어서 진행 이 글은 공식문서의 AOP부분을 참고하여 작성하였습니다.스프링 공식문서 AOP의 탄생 배경 개발을 하다 보면 여러 메서드에서 동일한 부가기능을 필요로 하게된다.그렇다면 무식하게 복붙 스킬을 써서 적용하면 된다고 생각할 수 있다. 하지만 이게 100개 이상이라면? 번거롭고 다른사람이 해당 작업을 할때 굉장히 부담스러워진다.결국 위와같은 문제를 해결하기 위해 나온 것이 AOP이다.핵심 로직과 부가 기능을 분리하고 한곳에 로직을 관리하는 기능을 만들었다. 이것이 @aspect 이다.aop는 oop와 같은 하나의 패러다임이고 많은 언어들이 지원하고 있고, Java에서는 AspectJ라는 방식으로 사용되고 있다.하지만 필자는 스프링을 사용하고 스프링에서는 AOP 프록시를 사용하기에 스프링 aop가 제공하는 기능을 말할 예정이다.   Spring AOP Aspect J join point 메서드 레벨만 지원함 생성자, 필드, 메서드 등 다양하게 지원 weaving 런타임 시에만 가능 런타임은 제공안하고 컴파일때,post컴파일 load time 때 제공 대상 Spring 컨테이너가 관리하는 bean만 모든 java Object에 가능 위빙: 옷감을 짜다 애스펙트와 실제 코드를 연결해서 붙이는 것 그래서 AOP 넌 뭔데? AOP를 알기 위해서는 우선 용어를 알아야한다.@Aspect : 여러 클래스에 흩어진 관심사의 모듈화Target : 어떤 대상에 부가기능을 부여할것인가Advice : before, afterReturning 등등 언제 사용할지? 아래 그림 참조Join point : 어디에 적용할 것인지? 메서드 (필드, 객체, 생성자)Point cut : 실제 advice가 적용될 지점, 즉 적용될 메서드 위치　 용어는 알겠고… 주의사항 스프링은 앞서 말했듯이 프록시 방식의 AOP를 사용한다. 이는 메서드 내부 호출에 프록시를 적용할 수 없는 치명적인 문제가 일어난다. ㅡ (해결방안 수정예정) 결론 AOP는 다양한 방면에서 우리가 알게 모르게 쓰고있다. filter, 인터셉터, @Transactional도 aop의 한 종류이다." }, { "title": "인터넷 사용법?", "url": "/posts/internetworks/", "categories": "CS, Internet", "tags": "cs, internet", "date": "2022-10-19 09:41:57 +0900", "snippet": "Internet 너는 대체 무엇인고? 🤷‍♂️전 세계에 걸쳐 파일 전송 등의 데이터 통신 서비스를 받을 수 있는 컴퓨터 네트워크 시스템이다.www.google.com을 찾아가는 데 있어서 바로 가는 것처럼 보이지만 수많은 노드들을 통해 지나간다.그런 과정들을 아래에 풀어보고자 한다.우선 처음으로 인지해야 하는 점은 계층에서 무슨 일이 일어나는지에 대한 로드맵이다.이는 인터넷에서 서로 다른 기종의 컴퓨터들이 서로 정보를 주고받는데 쓰이는 프로토콜의 집합을 뜻한다.아래의 방식의 규칙을 통해 우린 인터넷을 사용하고 있다.각 계층마다 무슨 액션을 했는지 알았으니,이젠 구글 URL 검색 시 무슨 일이 일어나는지… 컴퓨터가 구글닷컴을 어떻게 이해하는지 한번 보자.DNS? Domain Name Systemwww.google.com을 예로 들면 www를 제외한 나머지를 지칭하는 말이다.왜 이 말은 처음으로 시작했냐면….원래는 IP 주소인 123.456.789.000을 검색해서 들어가야 하는데 일일이 다 외울 수 없지 않은가? 우리도 누군가에게 전화할 때 전화번호부에서 이름을 검색해서 찾듯이 우리에게 도움 주는 프로토콜이 바로 DNS다.DNS 작동원리 브라우저에서 구글로 접속하려고 하는데 구글 서버의 IP를 모르는 상황 브라우저는 pc에 설정된 로컬 dns서버로 이동함. (통신사마다 local서버가 다르고, 또한 주소가 캐싱되어있다면 바로 반환함) 주소 값이 어딨는지 모르면 root 서버에게 요청을 보냄 (root dns 서버는 전 세계에 13군데가 있음) root서버는. com이라는 주소 값을 local dns서버로 반환함 그걸 토대로. com 담당 서버에게 보내줘서 해당 주소를 반환함. com서버가 보내준 결과를 토대로 google.com서버에 가서 주소 값을 얻어와서 마침내 브라우저에게 반환하고… ※ 여기서 장난질 치는 게 dns 스푸핑 브라우저에서 반환된 주소 값으로 구글 서버로 접속하게 된다. A Record는 뭐고 CNAME은 또 뭐지?A Record - IP와 도메인과의 직통 연결CNAME (canonical name) - IP가 유동적으로 변하는 서버를 위한 도메인 방식 (aws, firebase를 사용할 때)그럼 HTTP request 메시지를 구글 웹서버(포트 80)에게 보내는 것이다. 이 request를 위해서는 패킷을 만들어야 한다. 기본적인 HTTP 구조         Start Line 시작라인       Header 헤더       empty line 공백라인       Message body 메시지 바디       자세한 구조가 궁금하다면 CLI 창에 아래와같이 치면된다. curl -v www.google.com?query==http위와 같은 패킷을 통해 전송계층으로 진행한다면 TCP가 두두둥장한다.#TCP/전송계층Transport layer(전송계층)은 한 줄로 요약하면 \"End point 간 신뢰성 있는 데이터 전송을 담당하는 계층\"이다여기서 신뢰성은 데이터를 순차적, 안정적으로 전달 하는 걸 의미하고전송은 포트 번호에 해당하는 프로세스에 데이터를 전달하는 것을 의미한다.이외에도 TCP 프로토콜은 양방향 통신(3 way handshake), 흐름 제어, 혼합 제어, 오류 감지를 한다. (flow control,Congestion Control, Error Detection)TCP에서는 프로토콜 데이터 단위(PDU)로 세그먼트(Segment)를 사용하는데 큰 데이터를 잘게 잘라서BIG Data → (TCP Header + Data) + (TCP Header + Data) + (TCP Header + Data) 식으로 만든다.좀 더 자세히 알아보기 위해 아래 그림을 보자#TCP IP HEADER처음 보면 이거 뭐고…?라는 생각이 들것이다. 물론 당연한 생각이다. 하지만 여기선 빨간색으로 된 부분에 대한 얘기만 할 것이다. header에 이런 내용이 담겨있구나 정도만 알면 된다. 빨간색 부분 즉 컨트롤 비트를 이해하기 위해 3-way handshake로 설명하겠다.#3way handshake (connetion 연결) 처음 클라이언트가 서버에게 연결 요청할 때. SYN 플래그를 사용한다. SYN에다가 비트를 1로 설정해 패킷을 송신한다. 그럼 서버에서 ACK를 통해서 “내가 받았어!” 이런 제스처를 보낸다. 즉 ACK 비트를 1로 설정해서 패킷을 송신한다. 하지만, 그림에서는 서버에서 보낼 때 SYN도 비트를 1로 한다. 이유는 바로 앞서 말한 양방향 통신이기에 서버 또한 클라이언트한테 요청을 요하는 SYN을 사용한다. 그럼 클라이언트는 서버가 “오 나랑 연결에 응했네?”라며 ACK를 보내어 “나도 받았어”를 전달하는 방식이다.#3줄 요약.- SYN 연결 뚫을 때 사용함- ACK 뭔가를 받았을 때 보내야 하는 패킷, 만약 못 받았다? 그럼 일정 시간 있다가 또 패킷을 쏜다.- 이를 토대로 packet을 왔다 갔다 함.4 way handshake (connection close)통신을 종료할 때 사용되면서, 3 way와 비슷하게 “다 보냈어?”를 확인하는 FIN을 이용하는 것이 추가되었다.![image](https://github.com/msKim92/msKim92.github.io/blob/main/images/internet/5_4%20way%20handshake%20(connection%20close.jpg?raw=true)#이렇게 신뢰성도 보장해주고 흐름 제어도 해주고 만능인 것 같은 TCP도 사실 문제점이 있다.패킷을 중간에 잃어버리거나 도달하지 못하면 재전송해야 하는 점과 시간 손실이 발생된다.그래서 나온 게 UDP이다.순차 전송도 안 하고 흐름 제어도 안되고 혼잡 제어도 안되지만 전송 속도가 빠른 프로토콜이다.이유는 TCP는 데이터를 쪼개는 반면 UDP는 데이터 앞에 header만 장착 후 발송하기 때문이다.그래서 영상 스트리밍에서 자주 사용된다. (데이터의 신뢰성이 중요하지 않기 때문이다.)자 아무튼 이렇게 HandShaking을 통해서 드디어 연결이 이루어지고 데이터가 오가게 된다.그럼 데이터를 우쨰 보내야 하나….?IP 인터넷 계층 + Network Access Layer우리가 쓰는 컴퓨터는 보통 Private IP를 사용하고 있다. 그래서 공유기가 우리 소중한 IP주소를 public ip주소로 변환해준다.이것을 NAT (Network Address Translation)이라 한다. 그럼 변환된 친구는 수많은 라우터를 거쳐 목적지 서버까지 도착하게 된다.이제 아래의 그림을 보자.ARP 구도방식라우팅을 거쳐 구글 서버와 연결된 라우터에 데이터가 도착하면 시스템 A 상황에 온다. 그럼 노란색 말풍선처럼 IP해더가 기록된 구글 서버의 IP주소를 통해 MAC 주소를 얻어오려고 한다. 이때 사용되는 친구가 ARP다. 이 친구는 라우터가 연결된 네트워크로 브로드캐스팅시켜주는 프로토콜이다. 요청을 받은 system B (구글 서버)는 오케이! 너구나 하고 MAC 주소로 응답해준다.이제야 목적지 구글 서버의 MAC 주소를 이해했으니 데이터가 물리적으로 전달될 수 있는 것이다.데이터가 전송되었으니 이제 상호 간의 교류를 할 수 있다. Transport layer 전송계층을 목적지 포트번호를 통해서 이것을 보고 해당 번호에 데이터를 전달해야 주고 Application layer에 다다르면 웹 서버가 사용될 HTTP Request 데이터를 GET 요청을 통해 적절하게 데이터를 얻을 수 있게 된다. # 자주 사용되는 포트번호이러한 HTTP 요청과 응답 과정이 끝나면 연결을 종료해야 하는데 앞서 말한 4 handshaking 가 사용된다. 추가적으로 모든 과정이 끝나도 도착하지 못한 패킷이 있을 수도 있어서 일정 시간 소캣을 열어놓는다. 그런 잉여 패킷을 기다리는 상태를 TIME_WAIT이라 한다." }, { "title": "Java Syntex - hashmap", "url": "/posts/hashmap/", "categories": "Java, Algorithm", "tags": "java, algorithm", "date": "2022-10-12 13:11:04 +0900", "snippet": " Java Collections : Hashmap, linkedHashMap , TreeMap 차이 TreeMap 정렬이 되는데 오름차순이다.   Hashmap LinkedHashMap TreeMap 순서 X O O 정렬 X X O HashMap HashMap 생성 HashMap&lt;String,String&gt; map1 = new HashMap&lt;&gt;();//BasicHashMap&lt;String,String&gt; map2 = new HashMap&lt;&gt;(map1);//map1 복사HashMap&lt;String,String&gt; map3 = new HashMap&lt;&gt;(10);//사이즈 지정HashMap&lt;String,String&gt; map4 = new HashMap&lt;&gt;(10, 0.7f);//사이즈,load factor지정 HashMap 삭제 map.remove(1); //key값 1 제거map.clear(); //모든 값 제거 EntrySet() for (Entry&lt;Integer, String&gt; entry : map.entrySet()) { System.out.println(\"[Key]:\" + entry.getKey() + \" [Value]:\" + entry.getValue());}//IteratorIterator&lt;Entry&lt;Integer, String&gt;&gt; entries = map.entrySet().iterator();while(entries.hasNext()){ Map.Entry&lt;Integer, String&gt; entry = entries.next(); System.out.println(\"[Key]:\" + entry.getKey() + \" [Value]:\" + entry.getValue());} KeySet(), values()도있음 for(Integer i : map.keySet()){ //저장된 key값 확인 System.out.println(\"[Key]:\" + i + \" [Value]:\" + map.get(i));}//IteratorIterator&lt;Integer&gt; keys = map.keySet().iterator();while(keys.hasNext()){ int key = keys.next(); System.out.println(\"[Key]:\" + key + \" [Value]:\" + map.get(key));} getOrDefalut() 찾고자하는 Key가 존재한다면 key의 value값을 반환하고 없으면 default값을 반환한다.key가 중복되면 가지고 있던 값에다가 value값에 덮어쓰겠다.public static void main(String arg[]) { String [] abc = { \"A\", \"B\", \"C\" ,\"C\", \"C\"}; HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;(); for(String key : abc) { \thm.put(key, hm.getOrDefault(key, 0) + 1); } System.out.println(hm); //{A=1, B=1, C=3} } 참고자료 Head First 디자인패턴면접을 위한 CS 전공지식노트" }, { "title": "Basic Confusing Questions Ⅰ 🤷‍♂️ (13개)", "url": "/posts/java-basic-1/", "categories": "CS, Questions", "tags": "cs, questions", "date": "2022-10-07 19:41:57 +0900", "snippet": "Basic Confusing Questions Ⅰ 🤷‍♂️ 클릭하면 정답이 나옵니당~자바의 정석(남궁성 지음)에서 인용한 코드와 내용을 담고 있습니다. 데이터 타입중 기본형과 참조형의 차이 기본형 변수의 실제 데이터를 저장참조형 주소값의 데이터를 저장한다. 자바는 C와 다르게 참조형 변수끼리 연산이 안된다. 클래스와 객체에 대해 설명 객체 : 실제의 사물의 속성과 동작을 가지고 있고 다른것과 식별가능하냐… (붕어빵)클래스: 필드, 메서드, 생성자로 구성되어있는 객체의 설계도 (붕어빵 틀) 메서드 오버라이딩과 메서드 오버로딩의 차이   오버로딩 오버라이딩 메서드 이름 same same 메게변수, 타입 different same 리턴 타입 doesn`t matter smame 오버라이딩 : 상위 메서드에서 사용된 메서드를 자식 클래스에서 다시 호출해서 새로운 형태로 사용하는 행위, 리턴 타입이 동일해야함 부모에게서 상속받은 메소드의 내용과 자식클래스와 맞지않을 경우 자식클래스에서 동일한 메소드를 재정의/*-----------------------------------부모 클래스--------------------------------------*/class Man{ public String name; public int age; public void info(){ System.out.println(\"이 남자의 이름은 \"+name+\", 나이는 \"+age+\"살\"); } }/*----------------------------------자식 클래스---------------------------------------*/class Job extends Man{ String job; public void info() {//부모클래스에 있는 info()메서드를 재정의 super.info(); // 오버라이딩을 위한 super선언 필수 System.out.println(\"이 자의 직업은 \"+job); }}/*-------------------------------------메인 클래스-----------------------------------*/public class OverRidding { public static void main(String[] args) { Job job = new Job(); //Job 객체 생성 //변수 설정 job.name = \"민섭\"; job.age = 30; job.job = \"백엔드\"; job.info(); } } 오버로딩: 같은 이름으로 된 메서드를 매개변수, 타입만 다르게 해서 사용하는 행위 리턴타입 상관없음 하나의 클래스 안의 같은 이름의 메서드를 여러번 정의class Shape { public void area() { // 메서드 오버로딩. 같은 이름의 메서드 4개. System.out.println(\"넓이\"); } public void area(int r) { System.out.println(\"원 넓이 = \" + 3.14 * r * r); } public void area(int w, int l) { System.out.println(\"직사각형 넓이 = \" + w * l); } public void area(double b, double h) { System.out.println(\"삼각형 넓이 = \" + 0.5 * b * h); } jvm 동작 방식 [1] .Java → compiler → .class(바이트 코드) → JVM 코드를 입력하면 JVM머신으로 보내주기전에 Java Compiler에게 소스코드를 검사를 받고 컴파일을 진행한다..java 확장자를 가졌던 코드 → .class 확장자를 가진 java byte code로 변한다. [2] JVM 코드 실행을 위한 메모리 할당을 OS로 부터 받음 (메모리 할당) [3] Class Loader가 바이트코드 파일 → RuntimeData Area로 적재시킴 (자바소스코드 메모리 로드) [4] 로드 완료 후, Execution가 런타임 데이터 영역에 적재된 바이트 코드 실행 (2가지 방식으로 바이트 코드 실행) 4-1. 인터프리터 → 코드를 한줄씩 기계어로 번역하고 실행 4-2. Jit 컴파일러 → just in time complier로 바이트 코드 전부를 기계어로 번역하고 실행 ※ 차이 - 인터프리터를 기본으로 하다가 ‘반복되는 문장이 자주 실행된다’로 판단되면 jit 컴파일러 실행 자바의메모리 영역에 대해 설명 JVM에서 Runtime Data Area를 더 디테일하게 표현한 부분이다. 메서드 영역 (Method Area)클래스 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보와 같은 각종 필드 정보들과 메서드 정보, 데이터 Type 정보, Constant Pool, static변수, final class 등이 생성되는 영역이다. 힙 영역(Heap Area)JVM에는 하나의 heap영역만 존재함. 객체, 인스턴스 변수, 배열이되는 영역이다가비지컬랙션이 주기적으로 활동하는 영역이다 스택 영역 (Stack Area)지역변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값 등이 생성되는 영역이다 PC 레지스터 (PC Register)Thread가 생성될 때마다 생성되는 영역으로 프로그램 카운터, 즉 현재 스레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역이다 네이티브 메서드 스택 (Native Method Stack)JVM에서 C와 같은 Java 언어 이외의 네이티브 메서드를 지원하기 위해 사용하는 스택 구조의 메모리 영역이다 ※ 자바 이외의 언어(C++, 어셈블리 등)로 작성된 네이티브 코드를 실행할 때 사용되는 메모리 영역으로 일반적인 C 스택을 사용한다고 함. static, final 키워드에 대해 설명하고 언제 사용해야하는지 static = 공통적인 의 의미를 지니고 있다. 인스턴스에 상관없이 하나의 변수를 모든 인스턴스가 공유하기 떄문이다. final = 변경될수 없는의 의미를 지니고있다. 변수에 이용되면 상수가 되고, 메서드에 사용되면 오버라이딩이 불가능하며, 클래스에서 사용된다면 자손클래스를 정의할 수 없다. static 초기화 블럭은 클래스가 메모리에 로드될 때, 단 한번만 수행됨. //static 변수static int width = 200;&gt; 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 됨&gt; 클래스변수는 인스턴스를 생성하지않아도 사용가능&gt; 클래스 메모리에 로드될때 생성//static 메서드public static Method(){ ...}&gt; 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.&gt; static 메서드 내에 인스턴스맴버들을 직접 사용 할 수 없다. final class Final{ //조상이 될 수 없는 클래스 final int MAX_SIZE = 10; //값을 변경할 수 없는 상수 final void getSize(){ //오버라이딩 불가능한 메서드 final int LV = MAX_SIZE;//값 변경이 안되는 지역변수 return MAX_SIZE; }} OOP 장단점과 설명 절차 지향 대신 왜 우린 객체지향 프로그래밍을 하는 것인가? 절차 지향은 말처럼 순차적인 처리가 중요시하는 프로그램이다. 대표적으로는 C언어가 있다.컴퓨터의 일처리 방식과 유사해 실행 속도가 빠르다.하지만 리팩터링, 디버깅의 어려움, 순서가 바뀌면 결과가 바뀌는 등 단점이 많아서 나온 이론이 객체지향이다. 객체지향은... 실제 존재하는것과 객체들 간 상호작용을 컴퓨터 프로그래밍을 통해 구현하고자 함또한 이렇게 프로그램을 작성한다면 재사용성, 유지보수 용이, 중복 코드 감소 효과가 나타남. 단점으로는 설계에 많은 시간과 절차지향언어에 비해 상대적으로 실행속도가 느리다. 캡.상.추.다! 상속 (inherutance) = 확장과 분류용이, 중복코드 제거, 재사용성↑ 기존의 클래스를 기반으로 새로운 클래스를 작성 (a.k.a 자식 클래스가 부모 클래스의 특징과 기능을 따라 받는 것) 다중 상속 안됨 extends 키워드 사용 캡슐화 (encaspulation) = 데이터 보호와 은닉 속성(변수)과 기능(메서드)을 하나로 묶어서, public, private 같은 접근 지정자를 통해 제어하는 방법. getter/setter 사용 높은 응집도(Cohension) 낮은 결합도(Coupling)를 유지할 수 있도록 해주는 설계 방식 다형성 (polymorphism) = 오버 라이딩… 상위 클래스가 같은 메서드로 하위 클래스들을 서로 다르게 동작시킬 수 있다. 부모 클래스가 자식 클래스의 동작 방식을 알 수 없어도 오버 라이딩을 통해 자식 클래스를 접근할 수 있습니다. 상위 클래스 타입의 참조 변수로 하위 클래스 객체를 참조 (반대로 참조하는 경우는 안됨) 유지보수가 쉽고 재사용성이 좋고 결합이 느슨하도록 유지하는 방식 ex) SportCar() -&gt; Car() 일 경우 Car car = new car();SportCar Scar = new SportCar();Car Scar = new SportCar(); //가능SportCar Scar = new Car(); //불가능 추상화(Abstraction) = 공통된 특징을 하나의 개념화 abstract 키워드를 사용 공통된 특징인 만큼 반드시 사용되어야 하는 메서드를 선언해서 추상 클래스를 상속받는 모든 클래스들은 추상 메소드를 재정의 해야 함 다중 상속 불가능. 객체 생성 불가능 접근제어자의 특징과 종류에 대해서 설명 public: 접근 제한이 없다.default: 같은 패키지 내에서 접근 가능하다.protected: 같은 패키지와 다른 패키지의 자손클래스에서 접근이 된다.private: 같은 클래스 내에서만 접근이 가능하다. 추상 클래스와 인터페이스의 차이 추상클래스는 IS - A “~이다”. (다중상속 X)인터페이스는 HAS - A “~을 할 수 있는 (다중상속 O) 추상화(Abstraction) = 공통된 특징을 하나의 개념화 abstract 키워드를 사용 공통된 특징인 만큼 반드시 사용되어야 하는 메서드를 선언해서 추상 클래스를 상속받는 모든 클래스들은 추상 메소드를 재정의 해야 함 다중 상속 불가능. 객체 생성 불가능 인터페이스 (interface) = 역할과 구현의 구분 implements 키워드 사용 *상속보단 구현 모든 기능을 추상화로 정의만 하고 클래스 내에서 구현은 하지 않은 것. (미리 정해진 규칙에 맞게 구현하도록 표준을 제시) 인터페이스와 추상화의 차이점 - 기본 설계도와 미완성 설계도 추상클래스는 인스턴스 생성보다는 상속을 목적으로 하는 반면 인터페이스는 주로 제공할 기능을 정의하는 데 사용.추상클래스는 생성자 필드 일반, 추상 메서드를 포함할수있는 반면 인터페이스는 상수와 추상 메소드만 포함 할수 있다. 추상 클래스는 자신의 기능들을 하위 클래스로 확장 -&gt; 메서드를 자신 특징에 맞게 확장해서 사용, 변숫값 지정 없이 상황에 맞게끔 사용하면 된다. 인터페이스에 정의된 메소드를 각 클래스의 목적에 맞게 기능을 구현 -&gt; 클래스를 감싸서 직접적인 클래스 간의 종속관계를 벗어나게 해 줌 (독립성 확보) 이것은 유지보수에 있어서 유리함 또한 변숫값을 사용하려면 고정값을 줘야 함 이너클래스와 익명클래스, 장단점 내부 클래스는 클래스 내에 선언된 클래스이다.하나의 클래스를 다른 클래스의 내부 클래스로 선언하면 두 클래스의 맴버들간에 서로 쉽게 접근 할 수 있다는 점과외부의 불필요한 클래스를 감춤으로써 코드의 복잡성을 줄일수있다 -&gt; 캡슐화. class A{}class B{}----class A{ class B{ //내부 클래스 B }} 익명클래스: 이름이 없고, 클래스 선언과 동시에 객체를 생하기에 한번만 사용가능하며,오직 하나의 객체만을생성 할 수있는 일회용 클래스다시사용하지않는다고 하면 클래스를 만드는것보단 좋다. 득보다 실이 커보인다. 컬랙션과 스트림의 차이 설명 컬렉션과 배열의 차이는 메모리를 정적할당하냐 동적할당하냐의 차이이다. 컬렉션은 배열이 가장 기본적인 자료구조이며, DTO 또한 자료를 담는 하나의 방식 스트림은 선언형 코드로써 간결하고 가독성이 올라감. 어떻게 처리할 것인가 보단 무엇을 처리할지에 포커싱 데이터의 처리시점이 다르다. 컬렉션은 필요한 모든값이 계산되어 자료구조에 담겨야한다. 즉 저장하기 전에 모든 요소가 계산되어야 한다. 반면, 스트림은 데이터를 요청할 때만 계산함. 한번 소비하면 재사용이 되냐 안되냐컬렉션은 재사용이 가능하나 스트림은 한번 소비되면 재사용이 안된다. 컬렉션은 '외부반복', 스트림은 '내부반복'컬렉션을 반복하려면 iterator나 for를 써서 요소를 반복해야한다. 이를 외부반복이라 함스트림은 내부적으로 알아서 반복해서 결과를 알려준다. filter, map등의 연산 메소드에서는 반복이 내부적으로 숨겨져있고 추상화되어있다. 또한, 내부반복은 병렬성의 이점이 있다. 외부 반복을 사용하면 병렬성을 스스로 관리해야 한다. 병렬성을 스스로 관리한다는 것은 동기화 문제가 일어날 수 있는 부분들을 개발자가 신경써서 관리해야 한다는 말이다. 미처 파악하지 못한 사소한 이유로 문제가 발생할 가능성을 증가시킨다. parallel() 함수를 통해 병렬 처리를 지원하는데 이 때 병렬성 구현을 자동으로 선택해서 실행해준다. 스트림은 Java를 만든 개발자들에 의해 만들어졌다. Java의 내부 동작을 깊이있게 알고 있는 프로그래머들에 의해 만들어져 신뢰할 수 있다. 우리는 숨겨지고 추상화된 병렬 처리를 공개 API를 통해 간단히 사용할 수 있는 것이다. 물론 스트림이 내부적으로 사용하는 ForkJoin 프레임워크에 대한 이해와 병렬 연산을 올바르게 사용하기 위한 지식이 필요한건 물론이다. ※fork-join 프레임워크는 태스크(Task)를 재귀적으로 여러 개의 작은 작업 단위로 분할(fork)하여 처리한다. 처리된 서브 태스크들의 결과를 합쳐 전체 결과로 합친다(join). 참고 블로그 list ,set, map 차이점 List는 기본적으로 데이터들이 순서대로 저장되며 중복을 허용한다. Map은 순서가 보장되지 않고 Key값의 중복은 허용하지 않지만 Value값의 중복은 허용된다. Set은 순서가 보장되지 않고 데이터들의 중복을 허용하지 않는다. 제네릭에 대해서 설명하고 컬렉션 클래스에서 왜 제네릭을 사용하는지?\t 다양한 타입의 객체들을 다루는 메서드나 컬랙션 클래스에 컴파일 시 타입 체크를 해주는 기능. 타입의 안정성을 주고 타입체크와 형변환을 생략할 수 있어 코드가 간결해짐 " }, { "title": "상습적으로 틀리는 알고리즘 Hashmap", "url": "/posts/record-al/", "categories": "Note, Algorithm", "tags": "note, hashmap", "date": "2022-10-06 09:41:57 +0900", "snippet": "내가 자주 틀리는 알고리즘 유형 정리 🤷‍♂️ Hash, sliding window : 시간복잡도 O(n)key point는 pointer 개념을 이용해서 풀어야한다. 초기값 세팅시 -1 만큼 map에 저장 방향 lp, rp 개념을 이용하기 String에 저장하기보단 동적 메모리 arraylist를 쓰자. Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; compare = new HashMap&lt;&gt;(); int counter = 0; //초기값 세팅 for (int i = 0 ; i &lt; word.length() ; i++){ map.put(word.charAt(i), map.getOrDefault(word.charAt(i),0)+1); compare.put(str.charAt(i), compare.getOrDefault(str.charAt(i), 0) + 1); } compare.put(str.charAt(word.length() - 1), compare.getOrDefault(str.charAt(word.length() - 1),0)-1); int lp = 0; // 왼쪽 좌표 for (int rp = word.length() - 1; rp &lt; str.length(); rp++) { char Rchar = str.charAt(rp); char Lchar = str.charAt(lp); compare.put(Rchar, compare.getOrDefault(Rchar,0)+1); //rp 한칸 전진 if(map.equals(compare)) counter++; compare.put(Lchar, compare.getOrDefault(Lchar,0)- 1); //왼쪽 값 삭제 if(compare.get(Lchar)==0) compare.remove(Lchar); lp++; } System.out.println(counter); 재귀함수 메모이제이션import java.io.*;import java.util.*;public class Main { static int[] fibo; private static int solution(int i) { if(fibo[i]&gt;0) return fibo[i]; // 메모이제이션 포인트 //어차피 배열은 0으로 세팅되어있는데 값이 바뀌면 계산해놓은걸 참고해서 쓰면 좋지않은가 if (i == 1) return fibo[i] = 1; else if (i == 2) return fibo[i] = 1; else return fibo[i] = solution(i - 2) + solution(i - 1); } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int i = Integer.parseInt(br.readLine()); fibo = new int[i + 1]; solution(i); for (int x = 1 ; x &lt; fibo.length ; x++) System.out.printf(fibo[x]+\" \"); }}" } ]
